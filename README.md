<div dir="rtl">

به نام خدا

# توسعه آزمون‌رانه و پوشش آزمون (Test-driven Development and Test Coverage)


## استفاده از TDD
1.  در قسمت اول از پیدا کردن عیوب موجود در کد اصلی تست ای برای تابع lendBook نوشتیم که این تست در مسیر `src/test/classes/LibraryTest/` قرار دارد. در زیر تصاویر مربوط به تست نوشته شده و کد اصلاح شده را برای پاس کردن این تست داریم.

![](images/lendBookTest.png "تست نوشته شده برای تابع lendBook")

![](images/lendBookWrongResult.png "نتیجه اجرای تست برای تابع lendBook")

![](images/lendBookFixedCode.png "کد اصلاح شده تابع lendBook")

![](images/lendBookCorrectResult.png "نتیجه اجرای تست برای تابع lendBook پس از اصلاح")

####  ایراد موجود چک نکردن رجیستر بودن یا نبودن دانش آموز بود.

2. در قسمت دوم از پیدا کردن عیوب موجود در کد اصلی تست ای برای تابع returnBook نوشتیم که این تست در مسیر `src/test/classes/LibraryTest/` قرار دارد. در زیر تصاویر مربوط به تست نوشته شده و کد اصلاح شده را برای پاس کردن این تست داریم.

![](images/returnBookTest.png "تست نوشته شده برای تابع returnBook")

![](images/returnBookWrongResult.png "نتیجه اجرای تست برای تابع returnBook")

![](images/returnBookFixedCode.png "کد اصلاح شده تابع returnBook")

![](images/returnBookCorrectResult.png "نتیجه اجرای تست برای تابع returnBook پس از اصلاح")

####  ایراد موجود عدم حذف کتاب پس داده شده از لیست کتاب های دانش آموز بود.



3. در فایل
`Library.java`
دو تابع جستجو وجود دارد که باید با توجه به کامنت‌های آن‌ها و با استفاده از روش 
TDD
کاملشان کنید. برای این کار ابتدا تعدادی تست بنویسید که نیازمندی‌های این ۲ تابع را پوشش دهند، سپس ۲ تابع را به شکلی کامل کنید که همه آن‌ها پاس شوند.

گزارش مختصری از مراحل انجام آزمایش را در فایل README.md پروژه بنویسید.




## پرسش‌ها
پاسخ پرسش‌های زیر را داخل فایل README پروژه بنویسید:


۱. روش
TDD
را با روش تست کردن سنتی که در آن بعد از نوشتن برنامه، تست‌ها نوشته می‌شوند، از نظر نوع پروژه‌هایی که هر یک برای آن‌ها مناسب هست، مقایسه کنید.

توسعه مبتنی بر تست (TDD)

ابتدا به مزیت های TDD می پردازیم

افزایش کیفیت کد: با توجه به اینکه تست‌ها قبل از کد نوشته می‌شوند، کد نهایی تمیزتر و دارای کیفیت بالاتری خواهد بود.

شناسایی سریع باگ‌ها: تست‌های اولیه به شناسایی سریع‌تر مشکلات و خطاها کمک می‌کنند، زیرا کد به‌طور مداوم تحت آزمایش قرار می‌گیرد.

مستندسازی خودکار: تست‌ها خود به عنوان مستندات عمل می‌کنند و توضیح می‌دهند که کد چه کاری باید انجام دهد و چگونه باید عمل کند.

اما این روش نیز معایبی دارد:

نیاز به زمان و تلاش اولیه بیشتر: نوشتن تست‌ها قبل از کد اصلی ممکن است زمان‌بر باشد و تلاش بیشتری نیاز داشته باشد.

نیاز به تجربه و مهارت: برنامه‌نویسان باید تجربه و دانش کافی در زمینه نوشتن تست‌ها و پیاده‌سازی TDD داشته باشند.

این روش برای پروژه‌های زیر مناسب‌تر است:

پروژه‌های بزرگ و پیچیده: TDD برای پروژه‌های با پیچیدگی بالا و بخش‌های متعدد مفید است.

پروژه‌های حیاتی و حساس: در سیستم‌هایی که دقت و صحت عملکرد اهمیت بسیاری دارد، مانند سیستم‌های بانکی و پزشکی.

پروژه‌های بلند مدت: برای پروژه‌هایی که نیاز به نگهداری و توسعه مداوم دارند، TDD باعث می‌شود کد قابل فهم و تغییر باشد.

روش تست سنتی

در روش تست سنتی، برنامه‌نویسان ابتدا کد را می‌نویسند و سپس برای اطمینان از صحت عملکرد آن، تست‌های مختلفی را اجرا می‌کنند. این روش نیز مزایای خاص خود را دارد:

شروع سریع‌تر کدنویسی: برنامه‌نویسان می‌توانند بدون نیاز به نوشتن تست‌های اولیه، سریع‌تر به کدنویسی بپردازند.

سادگی فرآیند: این روش برای تیم‌هایی که 
تجربه کافی در TDD ندارند، ساده‌تر و قابل درک‌تر است.

معایب این روش شامل موارد زیر است:

احتمال وجود باگ‌های پنهان: ممکن است برخی مشکلات تا مراحل پایانی توسعه شناسایی نشوند، که می‌تواند هزینه‌بر و زمان‌بر باشد.
نیاز به هزینه بیشتر در بلند مدت: رفع باگ‌ها در مراحل بعدی توسعه می‌تواند هزینه و زمان بیشتری نیاز داشته باشد.
مستندسازی ناکافی: تست‌های نوشته شده ممکن است به عنوان مستندات کافی نباشند و کد نیاز به توضیحات اضافی داشته باشد.

این روش برای پروژه‌های زیر مناسب‌تر است:

پروژه‌های کوچک و کوتاه مدت: برای پروژه‌هایی که نیاز به زمان کوتاه‌تری دارند و پیچیدگی کمتری دارند.
پروژه‌های نمونه‌سازی سریع: در پروژه‌هایی که هدف اصلی ایجاد یک نمونه اولیه برای بررسی ایده‌ها و مفاهیم است.
تیم‌های مبتدی: تیم‌هایی که تجربه کمی در TDD دارند، می‌توانند با این روش کار خود را آغاز کنند.

جمع‌بندی

در نهایت، انتخاب بین TDD و روش تست سنتی بستگی به نوع پروژه و نیازهای تیم توسعه دارد. TDD برای پروژه‌های بزرگ، پیچیده و بلند مدت مناسب‌تر است زیرا کیفیت و قابلیت نگهداری کد را افزایش می‌دهد. اما برای پروژه‌های کوچک و کوتاه مدت یا تیم‌های با تجربه کمتر، روش تست سنتی می‌تواند ساده‌تر و سریع‌تر باشد.

---------

۲. در فرایند ایجاد نرم‌افزار هم تیم ایجاد
(Development Team)
و هم تیم تضمین کیفیت
(QA Team)
وظیفه تست نرم‌افزار را برعهده دارند.
هر کدام از این تیم‌ها بیش‌تر با کدام دسته از انواع تست سروکار دارد؟ چرا؟ انواع تست ذکر شده را به طور مختصر شرح دهید.


## تیم ایجاد (Development Team)

تیم توسعه بیش‌تر با تست‌هایی سروکار دارد که به کد و عملکرد فنی نرم‌افزار مرتبط هستند. این تست‌ها شامل موارد زیر می‌شوند:

تست واحد (Unit Testing):
شرح: تست واحد به بررسی صحت عملکرد کوچکترین واحدهای کد (مانند توابع یا متدها) می‌پردازد.

دلیل: توسعه‌دهندگان برای اطمینان از صحت عملکرد هر بخش کوچک از کد، تست‌های واحد را می‌نویسند و اجرا می‌کنند.

تست یکپارچگی (Integration Testing):
شرح: تست یکپارچگی بررسی می‌کند که آیا ماژول‌ها یا اجزای مختلف نرم‌افزار به درستی با یکدیگر تعامل دارند یا خیر.

دلیل: توسعه‌دهندگان نیاز دارند مطمئن شوند که ارتباط بین بخش‌های مختلف کد بدون مشکل است.

تست سیستم (System Testing):
شرح: تست سیستم به بررسی عملکرد کلی نرم‌افزار در محیطی مشابه با محیط نهایی می‌پردازد.

دلیل: توسعه‌دهندگان به تست سیستم می‌پردازند تا اطمینان حاصل کنند که تمامی اجزای نرم‌افزار با هم به درستی کار می‌کنند.

## تیم تضمین کیفیت (QA Team)

تیم تضمین کیفیت بیشتر با تست‌هایی سروکار دارد که به کیفیت نهایی و عملکرد کلی نرم‌افزار از دید کاربر و سازمان مرتبط هستند. این تست‌ها شامل موارد زیر می‌شوند:

تست پذیرش (Acceptance Testing):
شرح: تست پذیرش برای تأیید اینکه نرم‌افزار تمامی نیازمندی‌های کسب‌وکار و کاربر را برآورده می‌کند، انجام می‌شود.

دلیل: تیم QA این تست‌ها را انجام می‌دهد تا اطمینان حاصل کند که محصول نهایی مورد قبول مشتریان و ذینفعان قرار گیرد.

تست عملکرد (Performance Testing):
شرح: تست عملکرد برای بررسی کارایی نرم‌افزار در شرایط مختلف مانند بارگذاری بالا و استرس تست انجام می‌شود.

دلیل: تیم QA برای اطمینان از اینکه نرم‌افزار تحت شرایط مختلف به درستی عمل می‌کند، این تست‌ها را اجرا می‌کند.

تست امنیت (Security Testing):
شرح: تست امنیت به بررسی آسیب‌پذیری‌ها و نقاط ضعف نرم‌افزار از نظر امنیتی می‌پردازد.

دلیل: تیم QA مسئولیت دارد تا اطمینان حاصل کند که نرم‌افزار در برابر تهدیدات و حملات احتمالی مقاوم است.

تست رابط کاربری (UI Testing):
شرح: تست رابط کاربری بررسی می‌کند که رابط کاربری نرم‌افزار به درستی کار کرده و تجربه کاربری مناسبی ارائه می‌دهد.

دلیل: تیم QA این تست‌ها را انجام می‌دهد تا مطمئن شود که نرم‌افزار از نظر ظاهری و کاربری مشکلاتی ندارد و برای کاربران نهایی قابل استفاده است.

----
به طور خلاصه، تیم توسعه بیشتر با تست‌های فنی و کدنویسی (مثل تست واحد و یکپارچگی) سروکار دارد، زیرا این تست‌ها مستقیماً با عملکرد صحیح کد در ارتباط هستند. از طرف دیگر، تیم تضمین کیفیت بیشتر با تست‌هایی که به کیفیت نهایی و تجربه کاربری مربوط می‌شوند (مثل تست پذیرش، عملکرد، امنیت و رابط کاربری) سروکار دارد، چرا که این تست‌ها تضمین می‌کنند که نرم‌افزار نهایی مورد قبول کاربران و مشتریان باشد.

۳. روالی ‬‫را که‬ ‫برای‬ ‫پروژه‬ ‫‪json-simle‬‬ ‫ارائه‬ ‫شد‬،‬ ‫برای‬ پروژه ای که بر روی آن مشغول هستید هم‬ ‫انجام‬ ‫دهید.
برای ‫به‬ ‫دست‬‫‌آوردن‬ ‫اعداد‬ ‫پوشش‬ ‫آزمون‬ ‫کافی‬ ‫است‬ ‫بر‬ ‫روی‬ ‫پکیج‬ ‫‪java‬‬ ‫در‬ ‫مسیر‬ ‫‪test‬‬ ‫کلیک‬ ‫راست‬ ‫کرده‬ ‫و‬ ‫گزینه ‬‫‪coverage‬‬ ‫‪with‬‬ ‫‪Tests‬‬ ‫‪All‬‬ ‫‪Run‬‬ ‫را‬ ‫انتخاب‬ ‫کنید‬ ‫(نیازی‬ ‫به‬ ‫اجرای‬ ‫عادی‬ ‫پروژه‬ ‫نیست)‪.‬‬‫

این کار را انجام دادیم و نتیجه اولیه به این صورت بود :

![](images/FirstCoverage.png)

۴. با افزودن بخش‌هایی به کد تست، اعداد پوشش آزمون را در مورد تمامی کلاس‌های موجود در برنامه بهبود دهید. درصد افزایش اعداد پوشش آزمون مهم نیست ولی بخش‌هایی که به کد تست اضافه می‌شوند باید معنادار باشند و صرفاً یک فراخوانی ساده کلاس یا متد، بدون استفاده در بخش‌های دیگر کد کافی نیست. 

تکه کد زیر را اضافه کردیم :‌
```
@Test
    void displayBooks() {
        ArrayList<Book> books = new ArrayList<>();
        books.add(new Book("Book 1", "Author 1", 1));
        books.add(new Book("Book 2", "Author 2", 2));
        library.setBooks(books);

        library.displayBooks();

        String expectedOutput = "Available books in library:\n"
                + "Book 1 by Author 1\n"
                + "Book 2 by Author 2";
        Assertions.assertEquals(expectedOutput, outContent.toString().trim());
    }

    @Test
    void displayStudents() {
        ArrayList<Student> students = new ArrayList<>();
        students.add(new Student("Student 1", 1));
        students.add(new Student("Student 2", 2));
        library.setStudents(students);

        library.displayStudents();

        String expectedOutput = "Registered students:\n"
                + "Student 1|1\n"
                + "Student 2|2";

        Assertions.assertEquals(expectedOutput, outContent.toString().trim());
    }
```

و در نهایت همانطور که مشاهده می کنید درصد های method coverage افزایش یافت.

![](images/LastCoverage.png)

